#!/bin/bash

# ============================================================================
# Pre-Commit Hook: Secrets Scanning
# ============================================================================
# Prevents commits containing sensitive credentials (API keys, passwords, tokens)
# Uses detect-secrets tool to scan staged files for potential secrets
#
# Detects:
# - AWS credentials
# - GitHub tokens
# - OpenAI API keys
# - Database connection strings
# - Private keys and certificates
# - Generic password patterns
#
# Usage: Called automatically by git pre-commit hook
# Can be tested standalone: bash .husky/pre-commit-secrets-scan
# ============================================================================

set -e

# Source color utilities
source "$(dirname -- "$0")/colors.sh"

echo ""
echo "ðŸ” Running secrets scanning..."

# ============================================================================
# Configuration
# ============================================================================

BASELINE_FILE=".secrets.baseline"
SECRETS_FOUND=0
TEMP_SCAN_RESULTS="/tmp/secrets-scan-$$.json"

# Check if detect-secrets is available
if ! command -v detect-secrets &> /dev/null; then
  error "detect-secrets not found in PATH"
  echo ""
  echo "Please install detect-secrets:"
  echo "  pipx install detect-secrets"
  echo ""
  exit 1
fi

# ============================================================================
# Get Staged Files
# ============================================================================

# Get list of staged files (exclude deleted files)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR 2>/dev/null | grep -v "^$" || true)

if [ -z "$STAGED_FILES" ]; then
  success "No files to scan"
  exit 0
fi

debug "Found $(echo "$STAGED_FILES" | wc -l) staged files to scan"

# ============================================================================
# Run Secrets Scan
# ============================================================================

# Create a temporary list of staged files to scan
TEMP_FILES_LIST="/tmp/staged-files-$$.txt"
echo "$STAGED_FILES" > "$TEMP_FILES_LIST"

# Run detect-secrets on staged files
# We scan the actual file contents from the staging area
echo "ðŸ“‹ Scanning $(echo "$STAGED_FILES" | wc -l) staged files for secrets..."

# Create a temporary directory to hold staged file contents
TEMP_STAGED_DIR="/tmp/staged-checkout-$$"
mkdir -p "$TEMP_STAGED_DIR"

# Extract staged file contents to temp directory
while IFS= read -r file; do
  # Create directory structure
  dir=$(dirname "$file")
  mkdir -p "$TEMP_STAGED_DIR/$dir"

  # Get staged content and write to temp file
  git show ":$file" > "$TEMP_STAGED_DIR/$file" 2>/dev/null || true
done < "$TEMP_FILES_LIST"

# Run detect-secrets on the temporary staged directory
if detect-secrets scan \
  "$TEMP_STAGED_DIR" \
  --baseline "$BASELINE_FILE" \
  --all-files \
  --force-use-all-plugins \
  -o "$TEMP_SCAN_RESULTS" 2>/dev/null; then

  # Check if any secrets were found in the results
  if [ -f "$TEMP_SCAN_RESULTS" ]; then
    # Check if results contain any findings beyond the baseline
    FINDINGS=$(jq '.results | length' "$TEMP_SCAN_RESULTS" 2>/dev/null || echo "0")

    if [ "$FINDINGS" -gt 0 ]; then
      SECRETS_FOUND=1
    fi
  fi
else
  # detect-secrets might return non-zero if findings exist
  if [ -f "$TEMP_SCAN_RESULTS" ]; then
    FINDINGS=$(jq '.results | length' "$TEMP_SCAN_RESULTS" 2>/dev/null || echo "0")
    if [ "$FINDINGS" -gt 0 ]; then
      SECRETS_FOUND=1
    fi
  fi
fi

# ============================================================================
# Report Results
# ============================================================================

if [ $SECRETS_FOUND -eq 0 ]; then
  success "No secrets detected"

  # Cleanup temp files
  rm -f "$TEMP_FILES_LIST" "$TEMP_SCAN_RESULTS"
  rm -rf "$TEMP_STAGED_DIR"

  exit 0
else
  # Secrets were found - report and block commit
  echo ""
  error "Secrets detected in staged files!"
  echo ""

  # Parse and display findings
  if [ -f "$TEMP_SCAN_RESULTS" ]; then
    echo "ðŸ“ Findings:"

    # Extract findings using jq
    jq -r '.results | to_entries[] |
      "\(.value[].type): \(.key)"' "$TEMP_SCAN_RESULTS" 2>/dev/null | sort | uniq | while read -r finding; do

      # Extract file path and secret type
      file_path=$(echo "$finding" | cut -d: -f2- | sed 's/^ //')
      secret_type=$(echo "$finding" | cut -d: -f1)

      # Show relative path (strip temp directory prefix)
      display_path=$(echo "$file_path" | sed "s|$TEMP_STAGED_DIR/||")

      warning "$secret_type in $display_path"
    done
  fi

  echo ""
  echo "ðŸ”§ Required Actions:"
  echo ""
  echo "1. REMOVE the secret from your code:"
  echo "   - Delete the hardcoded API key, token, password, etc."
  echo "   - Do NOT just move it to comments"
  echo ""
  echo "2. MOVE secrets to environment variables:"
  echo "   - Create .env file with: SECRET_KEY=your_actual_key"
  echo "   - Reference in code: process.env.SECRET_KEY"
  echo "   - Add .env to .gitignore"
  echo ""
  echo "3. COMMON SECRET TYPES DETECTED:"
  echo "   - AWS Access Key: Begins with AKIA"
  echo "   - GitHub Token: Begins with ghp_ or ghu_"
  echo "   - OpenAI API Key: Begins with sk-"
  echo "   - Database URL: Contains username:password@host"
  echo "   - Private Keys: -----BEGIN RSA/OPENSSH PRIVATE KEY-----"
  echo ""
  echo "4. STAGE your changes again:"
  echo "   git add ."
  echo "   git commit -m 'your message'"
  echo ""
  echo "5. IF THIS IS A FALSE POSITIVE:"
  echo "   - Run: detect-secrets scan --baseline .secrets.baseline --update"
  echo "   - Then: git add .secrets.baseline && git commit"
  echo ""

  # Show which files contain findings
  echo "ðŸ“„ Files with secrets:"
  if [ -f "$TEMP_SCAN_RESULTS" ]; then
    jq -r '.results | keys[]' "$TEMP_SCAN_RESULTS" 2>/dev/null | sed 's|^'"$TEMP_STAGED_DIR/"'||' | while read -r file; do
      echo "  â€¢ $file"
    done
  fi

  echo ""
  echo "ðŸ“– More info: https://github.com/Yelp/detect-secrets"
  echo ""

  # Cleanup temp files
  rm -f "$TEMP_FILES_LIST" "$TEMP_SCAN_RESULTS"
  rm -rf "$TEMP_STAGED_DIR"

  exit 1
fi
