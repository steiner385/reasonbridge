// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client"
  output   = "../src/generated/client"
}

datasource db {
  provider = "postgresql"
}

// ============================================================================
// USER SERVICE ENTITIES
// ============================================================================

/// User account with trust scores and verification status
model User {
  id                     String            @id @default(uuid()) @db.Uuid
  email                  String            @unique
  displayName            String?           @map("display_name") @db.VarChar(50)
  cognitoSub             String            @unique @map("cognito_sub")
  // Onboarding fields
  authMethod             AuthMethod        @map("auth_method")
  emailVerified          Boolean           @default(false) @map("email_verified")
  passwordHash           String?           @map("password_hash")
  accountStatus          AccountStatus     @default(ACTIVE) @map("account_status")
  lastLoginAt            DateTime?         @map("last_login_at")
  // Phone verification
  phoneNumber            String?           @map("phone_number")
  phoneVerified          Boolean           @default(false) @map("phone_verified")
  // Trust & verification
  verificationLevel      VerificationLevel @default(BASIC) @map("verification_level")
  trustScoreAbility      Decimal           @default(0.50) @map("trust_score_ability") @db.Decimal(3, 2)
  trustScoreBenevolence  Decimal           @default(0.50) @map("trust_score_benevolence") @db.Decimal(3, 2)
  trustScoreIntegrity    Decimal           @default(0.50) @map("trust_score_integrity") @db.Decimal(3, 2)
  moralFoundationProfile Json?             @map("moral_foundation_profile")
  positionFingerprint    Json?             @map("position_fingerprint")
  topicAffinities        Json?             @map("topic_affinities")
  // AI Feedback preferences (T117)
  feedbackPreferences    Json?             @map("feedback_preferences")
  status                 UserStatus        @default(ACTIVE)
  createdAt              DateTime          @default(now()) @map("created_at")
  updatedAt              DateTime          @updatedAt @map("updated_at")

  // Relations
  verificationRecords   VerificationRecord[]
  videoUploads          VideoUpload[]
  following             UserFollow[]          @relation("Follower")
  followers             UserFollow[]          @relation("Followed")
  createdTopics         DiscussionTopic[]
  responses             Response[]
  votes                 Vote[]
  alignments            Alignment[]
  proposedTopicLinks    TopicLink[]           @relation("LinkProposer")
  createdPropositions   Proposition[]
  appeals               Appeal[]
  moderationApprovals   ModerationAction[]    @relation("ModeratorApproval")
  appealReviews         Appeal[]              @relation("AppealReviewer")
  topicInterests        TopicInterest[]
  // Feature 009: Discussion Participation
  createdDiscussions    Discussion[]
  participantActivities ParticipantActivity[]
  // Feature 016: Topic Management
  topicEdits            TopicEdit[]           @relation("TopicEditor")
  topicMerges           TopicMerge[]          @relation("TopicMerger")

  @@index([cognitoSub])
  @@index([email])
  @@index([displayName])
  @@index([emailVerified])
  @@index([phoneNumber])
  @@index([createdAt])
  @@map("users")
}

enum VerificationLevel {
  BASIC
  ENHANCED
  VERIFIED_HUMAN

  @@map("verification_level")
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  BANNED

  @@map("user_status")
}

/// Tracks user verification records (email, phone, government ID, video)
model VerificationRecord {
  id                String             @id @default(uuid()) @db.Uuid
  userId            String             @map("user_id") @db.Uuid
  type              VerificationType
  status            VerificationStatus @default(PENDING)
  verifiedAt        DateTime?          @map("verified_at")
  expiresAt         DateTime?          @map("expires_at")
  providerReference String?            @map("provider_reference")
  createdAt         DateTime           @default(now()) @map("created_at")

  // OTP-specific fields (otpCode stores bcrypt-hashed values, never plaintext)
  otpCode      String?   @map("otp_code") // bcrypt-hashed OTP (never store plaintext)
  otpExpiresAt DateTime? @map("otp_expires_at")
  otpAttempts  Int       @default(0) @map("otp_attempts")
  phoneNumber  String?   @map("phone_number")

  // Relations
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  videoUpload VideoUpload?

  @@index([userId, type])
  @@index([status])
  @@index([phoneNumber])
  @@map("verification_records")
}

/// Tracks video uploads for video verification
model VideoUpload {
  id             String    @id @default(uuid()) @db.Uuid
  verificationId String    @unique @map("verification_id") @db.Uuid
  userId         String    @map("user_id") @db.Uuid
  s3Key          String    @map("s3_key")
  s3Url          String    @map("s3_url")
  fileName       String    @map("file_name")
  fileSize       Int       @map("file_size")
  mimeType       String    @map("mime_type")
  uploadedAt     DateTime  @default(now()) @map("uploaded_at")
  completedAt    DateTime? @map("completed_at")
  expiresAt      DateTime  @map("expires_at")
  createdAt      DateTime  @default(now()) @map("created_at")

  // Relations
  verification VerificationRecord @relation(fields: [verificationId], references: [id], onDelete: Cascade)
  user         User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([verificationId])
  @@index([userId])
  @@index([expiresAt])
  @@map("video_uploads")
}

enum VerificationType {
  EMAIL
  PHONE
  GOVERNMENT_ID
  VIDEO

  @@map("verification_type")
}

enum VerificationStatus {
  PENDING
  VERIFIED
  REJECTED
  EXPIRED

  @@map("verification_status")
}

/// Tracks user follow relationships
/// Note: Self-follows must be prevented at application level (follower_id != followed_id)
model UserFollow {
  id         String   @id @default(uuid()) @db.Uuid
  followerId String   @map("follower_id") @db.Uuid
  followedId String   @map("followed_id") @db.Uuid
  createdAt  DateTime @default(now()) @map("created_at")

  // Relations
  follower User @relation("Follower", fields: [followerId], references: [id], onDelete: Cascade)
  followed User @relation("Followed", fields: [followedId], references: [id], onDelete: Cascade)

  @@unique([followerId, followedId])
  @@index([followerId])
  @@index([followedId])
  @@map("user_follows")
}

// ============================================================================
// DISCUSSION SERVICE ENTITIES
// ============================================================================

/// A discussion topic with tags and propositions
/// Validation rules enforced at application level:
/// - Title must be 10-200 characters (schema enforces max 200 via VarChar)
/// - Requires 2-5 tags (enforced via TopicTag relations)
/// - Cannot transition to ACTIVE until minimum_diversity_score is met
model DiscussionTopic {
  id                    String           @id @default(uuid()) @db.Uuid
  title                 String           @db.VarChar(200)
  description           String           @db.Text
  creatorId             String           @map("creator_id") @db.Uuid
  status                TopicStatus      @default(SEEDING)
  // T001: New fields for topic management
  visibility            TopicVisibility  @default(PUBLIC)
  slug                  String           @unique @db.VarChar(250)
  lastActivityAt        DateTime         @default(now()) @map("last_activity_at")
  lockedAt              DateTime?        @map("locked_at")
  evidenceStandards     EvidenceStandard @default(STANDARD) @map("evidence_standards")
  minimumDiversityScore Decimal          @default(0.30) @map("minimum_diversity_score") @db.Decimal(3, 2)
  currentDiversityScore Decimal?         @map("current_diversity_score") @db.Decimal(3, 2)
  participantCount      Int              @default(0) @map("participant_count")
  responseCount         Int              @default(0) @map("response_count")
  // Onboarding fields
  activeDiscussionCount Int              @default(0) @map("active_discussion_count")
  activityLevel         ActivityLevel    @default(LOW) @map("activity_level")
  suggestedForNewUsers  Boolean          @default(false) @map("suggested_for_new_users")
  crossCuttingThemes    String[]         @map("cross_cutting_themes")
  createdAt             DateTime         @default(now()) @map("created_at")
  activatedAt           DateTime?        @map("activated_at")
  archivedAt            DateTime?        @map("archived_at")

  // Relations
  creator              User                   @relation(fields: [creatorId], references: [id])
  tags                 TopicTag[]
  sourceLinks          TopicLink[]            @relation("SourceTopic")
  targetLinks          TopicLink[]            @relation("TargetTopic")
  propositions         Proposition[]
  responses            Response[]
  commonGroundAnalyses CommonGroundAnalysis[]
  topicInterests       TopicInterest[]
  Discussion           Discussion[]
  // T002: New relations for topic management
  editHistory          TopicEdit[]
  mergesAsTarget       TopicMerge[]           @relation("TargetTopicMerge")
  // T038: Analytics relation
  analytics            TopicAnalytics[]

  @@index([status])
  @@index([creatorId])
  @@index([createdAt(sort: Desc)])
  @@index([activityLevel])
  @@index([suggestedForNewUsers])
  // T001: New indexes for topic management
  @@index([slug])
  @@index([visibility])
  @@index([lastActivityAt(sort: Desc)])
  @@index([status, visibility])
  @@map("discussion_topics")
}

enum TopicStatus {
  SEEDING
  ACTIVE
  ARCHIVED
  LOCKED // T001: Added for topic management

  @@map("topic_status")
}

// T001: New enum for topic visibility control
enum TopicVisibility {
  PUBLIC
  PRIVATE
  UNLISTED

  @@map("topic_visibility")
}

enum EvidenceStandard {
  MINIMAL
  STANDARD
  RIGOROUS

  @@map("evidence_standard")
}

/// T002: Edit history tracking for topics (Feature 016: Topic Management)
/// Immutable audit trail - no updates, only inserts
model TopicEdit {
  id              String   @id @default(uuid()) @db.Uuid
  topicId         String   @map("topic_id") @db.Uuid
  editorId        String   @map("editor_id") @db.Uuid
  editedAt        DateTime @default(now()) @map("edited_at")

  // Changed fields (null if unchanged)
  previousTitle       String? @map("previous_title") @db.VarChar(200)
  newTitle            String? @map("new_title") @db.VarChar(200)
  previousDescription String? @map("previous_description") @db.Text
  newDescription      String? @map("new_description") @db.Text
  previousTags        String[] @default([]) @map("previous_tags")
  newTags             String[] @default([]) @map("new_tags")

  changeReason    String? @map("change_reason") @db.Text
  flaggedForReview Boolean @default(false) @map("flagged_for_review")

  // Relations
  topic  DiscussionTopic @relation(fields: [topicId], references: [id], onDelete: Cascade)
  editor User            @relation("TopicEditor", fields: [editorId], references: [id])

  @@index([topicId, editedAt(sort: Desc)])
  @@index([editorId])
  @@index([flaggedForReview])
  @@map("topic_edits")
}

/// T003: Topic merge operations (Feature 016: Topic Management)
/// Tracks merge history for rollback and audit purposes
model TopicMerge {
  id                String    @id @default(uuid()) @db.Uuid
  sourceTopicIds    String[]  @map("source_topic_ids") @db.Uuid
  targetTopicId     String    @map("target_topic_id") @db.Uuid
  moderatorId       String    @map("moderator_id") @db.Uuid
  mergeReason       String    @map("merge_reason") @db.Text
  mergedAt          DateTime  @default(now()) @map("merged_at")

  // Rollback support (30-day window)
  rolledBackAt      DateTime? @map("rolled_back_at")
  rollbackReason    String?   @map("rollback_reason") @db.Text

  // Snapshot of merged data for rollback
  sourceSnapshots   Json      @map("source_snapshots") // Original topic data
  responsesMoved    Int       @default(0) @map("responses_moved")
  participantsMerged Int      @default(0) @map("participants_merged")

  // Relations
  targetTopic DiscussionTopic @relation("TargetTopicMerge", fields: [targetTopicId], references: [id])
  moderator   User            @relation("TopicMerger", fields: [moderatorId], references: [id])

  @@index([targetTopicId])
  @@index([moderatorId])
  @@index([mergedAt])
  @@index([rolledBackAt])
  @@map("topic_merges")
}

/// T038 [US5]: Topic analytics for pre-aggregated metrics (Feature 016)
/// Stores daily aggregated metrics for efficient analytics queries
/// Real-time metrics are computed on-demand by TopicsAnalyticsService
model TopicAnalytics {
  id              String   @id @default(uuid()) @db.Uuid
  topicId         String   @map("topic_id") @db.Uuid
  date            DateTime @db.Date // Aggregation date (daily)

  // View metrics
  viewCount       Int      @default(0) @map("view_count")
  uniqueViewers   Int      @default(0) @map("unique_viewers")

  // Participation metrics
  responseCount   Int      @default(0) @map("response_count")
  participantCount Int     @default(0) @map("participant_count")
  newParticipants Int      @default(0) @map("new_participants")

  // Engagement metrics
  avgResponseLength Int    @default(0) @map("avg_response_length")
  engagementScore   Decimal @default(0) @map("engagement_score") @db.Decimal(5, 2)

  // Time-based metrics
  peakActivityHour  Int?   @map("peak_activity_hour") // Hour of day (0-23)

  // Timestamps
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  topic DiscussionTopic @relation(fields: [topicId], references: [id], onDelete: Cascade)

  @@unique([topicId, date])
  @@index([topicId, date(sort: Desc)])
  @@index([date])
  @@map("topic_analytics")
}

/// Tags for categorizing discussion topics
/// Validation: Name must be 2-50 characters (max 50 enforced by VarChar, min 2 at application level)
model Tag {
  id            String   @id @default(uuid()) @db.Uuid
  name          String   @unique @db.VarChar(50)
  slug          String   @unique
  usageCount    Int      @default(0) @map("usage_count")
  aiSynonyms    String[] @map("ai_synonyms")
  parentThemeId String?  @map("parent_theme_id") @db.Uuid
  createdAt     DateTime @default(now()) @map("created_at")

  // Relations
  parentTheme Tag?       @relation("TagHierarchy", fields: [parentThemeId], references: [id])
  childThemes Tag[]      @relation("TagHierarchy")
  topics      TopicTag[]

  @@index([usageCount(sort: Desc)])
  @@map("tags")
}

/// Junction table for topic-tag relationships
model TopicTag {
  topicId   String    @map("topic_id") @db.Uuid
  tagId     String    @map("tag_id") @db.Uuid
  source    TagSource
  createdAt DateTime  @default(now()) @map("created_at")

  // Relations
  topic DiscussionTopic @relation(fields: [topicId], references: [id], onDelete: Cascade)
  tag   Tag             @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([topicId, tagId])
  @@index([tagId])
  @@map("topic_tags")
}

enum TagSource {
  CREATOR
  AI_SUGGESTED
  COMMUNITY

  @@map("tag_source")
}

/// Links between related discussion topics
/// Unique constraint prevents duplicate links of same type between same topics
model TopicLink {
  id                 String                @id @default(uuid()) @db.Uuid
  sourceTopicId      String                @map("source_topic_id") @db.Uuid
  targetTopicId      String                @map("target_topic_id") @db.Uuid
  relationshipType   TopicRelationshipType @map("relationship_type")
  linkSource         LinkSource            @map("link_source")
  proposerId         String?               @map("proposer_id") @db.Uuid
  confirmationStatus ConfirmationStatus    @default(PENDING) @map("confirmation_status")
  confirmedByCount   Int                   @default(0) @map("confirmed_by_count")
  rejectedByCount    Int                   @default(0) @map("rejected_by_count")
  createdAt          DateTime              @default(now()) @map("created_at")

  // Relations
  sourceTopic DiscussionTopic @relation("SourceTopic", fields: [sourceTopicId], references: [id], onDelete: Cascade)
  targetTopic DiscussionTopic @relation("TargetTopic", fields: [targetTopicId], references: [id], onDelete: Cascade)
  proposer    User?           @relation("LinkProposer", fields: [proposerId], references: [id])

  @@unique([sourceTopicId, targetTopicId, relationshipType])
  @@index([sourceTopicId])
  @@index([targetTopicId])
  @@index([relationshipType])
  @@index([confirmationStatus])
  @@map("topic_links")
}

enum TopicRelationshipType {
  BUILDS_ON
  RESPONDS_TO
  CONTRADICTS
  RELATED
  SHARES_PROPOSITION

  @@map("topic_relationship_type")
}

enum LinkSource {
  AI_SUGGESTED
  USER_PROPOSED

  @@map("link_source")
}

enum ConfirmationStatus {
  PENDING
  CONFIRMED
  REJECTED

  @@map("confirmation_status")
}

/// A proposition/claim within a discussion topic
model Proposition {
  id                  String            @id @default(uuid()) @db.Uuid
  topicId             String            @map("topic_id") @db.Uuid
  statement           String            @db.VarChar(1000)
  source              PropositionSource
  creatorId           String?           @map("creator_id") @db.Uuid
  parentPropositionId String?           @map("parent_proposition_id") @db.Uuid
  supportCount        Int               @default(0) @map("support_count")
  opposeCount         Int               @default(0) @map("oppose_count")
  nuancedCount        Int               @default(0) @map("nuanced_count")
  consensusScore      Decimal?          @map("consensus_score") @db.Decimal(3, 2)
  evidencePool        Json?             @map("evidence_pool")
  status              PropositionStatus @default(ACTIVE)
  createdAt           DateTime          @default(now()) @map("created_at")

  // Relations
  topic             DiscussionTopic       @relation(fields: [topicId], references: [id], onDelete: Cascade)
  creator           User?                 @relation(fields: [creatorId], references: [id])
  parentProposition Proposition?          @relation("PropositionHierarchy", fields: [parentPropositionId], references: [id])
  childPropositions Proposition[]         @relation("PropositionHierarchy")
  alignments        Alignment[]
  responses         ResponseProposition[]

  @@index([topicId])
  @@index([parentPropositionId])
  @@index([topicId, consensusScore(sort: Desc)])
  @@map("propositions")
}

enum PropositionSource {
  AI_IDENTIFIED
  USER_CREATED

  @@map("proposition_source")
}

enum PropositionStatus {
  ACTIVE
  MERGED
  ARCHIVED

  @@map("proposition_status")
}

/// A response/comment in a discussion topic
model Response {
  id                    String         @id @default(uuid()) @db.Uuid
  topicId               String         @map("topic_id") @db.Uuid
  // T005 [P] - NEW: Link response to specific discussion (nullable during migration)
  discussionId          String?        @map("discussion_id") @db.Uuid
  authorId              String         @map("author_id") @db.Uuid
  parentId              String?        @map("parent_id") @db.Uuid
  content               String         @db.Text
  citedSources          Json?          @map("cited_sources")
  containsOpinion       Boolean        @default(false) @map("contains_opinion")
  containsFactualClaims Boolean        @default(false) @map("contains_factual_claims")
  status                ResponseStatus @default(VISIBLE)
  // T004 [P] - NEW: Optimistic locking and edit tracking (Feature 009)
  version               Int            @default(1)
  deletedAt             DateTime?      @map("deleted_at")
  editedAt              DateTime?      @map("edited_at")
  editCount             Int            @default(0) @map("edit_count")
  revisionCount         Int            @default(0) @map("revision_count")
  createdAt             DateTime       @default(now()) @map("created_at")
  updatedAt             DateTime       @updatedAt @map("updated_at")

  // Relations
  topic            DiscussionTopic       @relation(fields: [topicId], references: [id], onDelete: Cascade)
  // T005 [P] - NEW: Discussion relation (nullable during migration)
  discussion       Discussion?           @relation("DiscussionResponses", fields: [discussionId], references: [id], onDelete: Cascade)
  author           User                  @relation(fields: [authorId], references: [id])
  parent           Response?             @relation("ResponseThreading", fields: [parentId], references: [id], onDelete: Cascade)
  replies          Response[]            @relation("ResponseThreading")
  propositions     ResponseProposition[]
  feedback         Feedback[]
  factCheckResults FactCheckResult[]
  votes            Vote[]
  // T002 [P] - NEW: Citations relation (Feature 009)
  citations        Citation[]

  @@index([topicId])
  // T004 [P] & T005 [P] - NEW: Indexes for soft delete and discussion filtering
  @@index([discussionId, deletedAt])
  @@index([deletedAt])
  @@index([authorId])
  @@index([parentId])
  @@index([topicId, createdAt(sort: Desc)])
  @@index([status])
  @@map("responses")
}

enum ResponseStatus {
  VISIBLE
  HIDDEN
  REMOVED

  @@map("response_status")
}

/// Junction table for response-proposition relationships
model ResponseProposition {
  responseId     String   @map("response_id") @db.Uuid
  propositionId  String   @map("proposition_id") @db.Uuid
  relevanceScore Decimal? @map("relevance_score") @db.Decimal(3, 2)

  // Relations
  response    Response    @relation(fields: [responseId], references: [id], onDelete: Cascade)
  proposition Proposition @relation(fields: [propositionId], references: [id], onDelete: Cascade)

  @@id([responseId, propositionId])
  @@map("response_propositions")
}

/// Vote on a response (upvote/downvote)
model Vote {
  id         String   @id @default(uuid()) @db.Uuid
  userId     String   @map("user_id") @db.Uuid
  responseId String   @map("response_id") @db.Uuid
  voteType   VoteType @map("vote_type")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  // Relations
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  response Response @relation(fields: [responseId], references: [id], onDelete: Cascade)

  @@unique([userId, responseId])
  @@index([responseId])
  @@index([userId])
  @@map("votes")
}

enum VoteType {
  UPVOTE
  DOWNVOTE

  @@map("vote_type")
}

/// User alignment (support/oppose/nuanced) on a proposition
model Alignment {
  id                String          @id @default(uuid()) @db.Uuid
  userId            String          @map("user_id") @db.Uuid
  propositionId     String          @map("proposition_id") @db.Uuid
  stance            AlignmentStance
  nuanceExplanation String?         @map("nuance_explanation") @db.Text
  createdAt         DateTime        @default(now()) @map("created_at")
  updatedAt         DateTime        @updatedAt @map("updated_at")

  // Relations
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  proposition Proposition @relation(fields: [propositionId], references: [id], onDelete: Cascade)

  @@unique([userId, propositionId])
  @@index([propositionId])
  @@map("alignments")
}

enum AlignmentStance {
  SUPPORT
  OPPOSE
  NUANCED

  @@map("alignment_stance")
}

/// AI-generated common ground analysis for a topic
model CommonGroundAnalysis {
  id                           String   @id @default(uuid()) @db.Uuid
  topicId                      String   @map("topic_id") @db.Uuid
  version                      Int
  agreementZones               Json     @map("agreement_zones")
  misunderstandings            Json
  genuineDisagreements         Json     @map("genuine_disagreements")
  overallConsensusScore        Decimal? @map("overall_consensus_score") @db.Decimal(3, 2)
  participantCountAtGeneration Int      @map("participant_count_at_generation")
  responseCountAtGeneration    Int      @map("response_count_at_generation")
  modelVersion                 String   @map("model_version")
  createdAt                    DateTime @default(now()) @map("created_at")

  // Relations
  topic DiscussionTopic @relation(fields: [topicId], references: [id], onDelete: Cascade)

  @@index([topicId])
  @@index([topicId, version(sort: Desc)])
  @@map("common_ground_analyses")
}

/// T001 [P] - Specific discussion thread within a topic (Feature 009)
/// A user-created conversation with a title and initial response
enum DiscussionStatus {
  ACTIVE
  ARCHIVED
  DELETED

  @@map("discussion_status")
}

model Discussion {
  id               String           @id @default(uuid()) @db.Uuid
  topicId          String           @map("topic_id") @db.Uuid
  creatorId        String           @map("creator_id") @db.Uuid
  title            String           @db.VarChar(200)
  status           DiscussionStatus @default(ACTIVE)
  responseCount    Int              @default(0) @map("response_count")
  participantCount Int              @default(0) @map("participant_count")
  lastActivityAt   DateTime         @default(now()) @map("last_activity_at")
  createdAt        DateTime         @default(now()) @map("created_at")
  updatedAt        DateTime         @updatedAt @map("updated_at")

  // Relations
  topic                 DiscussionTopic       @relation(fields: [topicId], references: [id], onDelete: Cascade)
  creator               User                  @relation(fields: [creatorId], references: [id])
  responses             Response[]            @relation("DiscussionResponses")
  participantActivities ParticipantActivity[]

  @@index([topicId, status, lastActivityAt(sort: Desc)])
  @@index([creatorId])
  @@index([status])
  @@index([createdAt(sort: Desc)])
  @@map("discussions")
}

/// T002 [P] - Citation/source reference attached to a response (Feature 009)
enum CitationValidationStatus {
  ACTIVE // HTTP 2xx-3xx response
  BROKEN // HTTP 4xx-5xx response
  UNVERIFIED // Not yet checked or timeout

  @@map("citation_validation_status")
}

model Citation {
  id               String                   @id @default(uuid()) @db.Uuid
  responseId       String                   @map("response_id") @db.Uuid
  originalUrl      String                   @map("original_url") @db.VarChar(2048)
  normalizedUrl    String                   @map("normalized_url") @db.VarChar(2048)
  title            String?                  @db.VarChar(500)
  resolvedIp       String?                  @map("resolved_ip") @db.VarChar(45)
  validationStatus CitationValidationStatus @default(UNVERIFIED) @map("validation_status")
  validatedAt      DateTime?                @map("validated_at")
  createdAt        DateTime                 @default(now()) @map("created_at")

  // Relations
  response Response @relation(fields: [responseId], references: [id], onDelete: Cascade)

  @@index([responseId])
  @@index([normalizedUrl])
  @@index([validationStatus])
  @@map("citations")
}

/// T003 [P] - Track user participation in discussions (Feature 009)
model ParticipantActivity {
  id                  String   @id @default(uuid()) @db.Uuid
  discussionId        String   @map("discussion_id") @db.Uuid
  userId              String   @map("user_id") @db.Uuid
  firstContributionAt DateTime @default(now()) @map("first_contribution_at")
  lastContributionAt  DateTime @default(now()) @map("last_contribution_at")
  responseCount       Int      @default(1) @map("response_count")

  // Relations
  discussion Discussion @relation(fields: [discussionId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([discussionId, userId])
  @@index([discussionId])
  @@index([userId])
  @@map("participant_activities")
}

// ============================================================================
// AI SERVICE ENTITIES
// ============================================================================

/// AI-generated feedback on a response
model Feedback {
  id                   String         @id @default(uuid()) @db.Uuid
  responseId           String         @map("response_id") @db.Uuid
  type                 FeedbackType
  subtype              String?
  suggestionText       String         @map("suggestion_text") @db.Text
  reasoning            String         @db.Text
  confidenceScore      Decimal        @map("confidence_score") @db.Decimal(3, 2)
  educationalResources Json?          @map("educational_resources")
  userAcknowledged     Boolean        @default(false) @map("user_acknowledged")
  userRevised          Boolean        @default(false) @map("user_revised")
  userHelpfulRating    HelpfulRating? @map("user_helpful_rating")
  dismissedAt          DateTime?      @map("dismissed_at")
  dismissalReason      String?        @map("dismissal_reason")
  displayedToUser      Boolean        @map("displayed_to_user")
  createdAt            DateTime       @default(now()) @map("created_at")

  // Relations
  response Response @relation(fields: [responseId], references: [id], onDelete: Cascade)

  @@index([responseId])
  @@index([type])
  @@index([displayedToUser, createdAt])
  @@map("feedback")
}

enum FeedbackType {
  FALLACY
  INFLAMMATORY
  UNSOURCED
  BIAS
  AFFIRMATION

  @@map("feedback_type")
}

enum HelpfulRating {
  HELPFUL
  NOT_HELPFUL

  @@map("helpful_rating")
}

// ============================================================================
// FACT-CHECK SERVICE ENTITIES
// ============================================================================

/// Fact-check results for claims in responses
model FactCheckResult {
  id                    String   @id @default(uuid()) @db.Uuid
  responseId            String   @map("response_id") @db.Uuid
  claimText             String   @map("claim_text") @db.Text
  claimStartOffset      Int      @map("claim_start_offset")
  claimEndOffset        Int      @map("claim_end_offset")
  sources               Json
  hasConflictingSources Boolean  @default(false) @map("has_conflicting_sources")
  displayedAs           String   @default("Related Context") @map("displayed_as")
  createdAt             DateTime @default(now()) @map("created_at")
  expiresAt             DateTime @map("expires_at")

  // Relations
  response Response @relation(fields: [responseId], references: [id], onDelete: Cascade)

  @@index([responseId])
  @@index([expiresAt])
  @@map("fact_check_results")
}

// ============================================================================
// MODERATION SERVICE ENTITIES
// ============================================================================

/// Moderation actions taken on content or users
model ModerationAction {
  id            String               @id @default(uuid()) @db.Uuid
  targetType    ModerationTargetType @map("target_type")
  targetId      String               @map("target_id") @db.Uuid
  actionType    ModerationActionType @map("action_type")
  severity      ModerationSeverity
  reasoning     String               @db.Text
  aiRecommended Boolean              @default(false) @map("ai_recommended")
  aiConfidence  Decimal?             @map("ai_confidence") @db.Decimal(3, 2)
  approvedById  String?              @map("approved_by_id") @db.Uuid
  approvedAt    DateTime?            @map("approved_at")
  status        ModerationStatus     @default(PENDING)
  createdAt     DateTime             @default(now()) @map("created_at")
  executedAt    DateTime?            @map("executed_at")

  // Temporary ban fields
  isTemporary     Boolean?  @default(false) @map("is_temporary")
  banDurationDays Int?      @map("ban_duration_days")
  expiresAt       DateTime? @map("expires_at")
  liftedAt        DateTime? @map("lifted_at")

  // Relations
  approvedBy User?    @relation("ModeratorApproval", fields: [approvedById], references: [id])
  appeals    Appeal[]

  @@index([targetType, targetId])
  @@index([status])
  @@index([severity])
  @@index([expiresAt]) // For finding expired bans
  @@map("moderation_actions")
}

enum ModerationTargetType {
  RESPONSE
  USER
  TOPIC

  @@map("moderation_target_type")
}

enum ModerationActionType {
  EDUCATE
  WARN
  HIDE
  REMOVE
  SUSPEND
  BAN

  @@map("moderation_action_type")
}

enum ModerationSeverity {
  NON_PUNITIVE
  CONSEQUENTIAL

  @@map("moderation_severity")
}

enum ModerationStatus {
  PENDING
  ACTIVE
  APPEALED
  REVERSED

  @@map("moderation_status")
}

/// Appeals against moderation actions
model Appeal {
  id                 String       @id @default(uuid()) @db.Uuid
  moderationActionId String       @map("moderation_action_id") @db.Uuid
  appellantId        String       @map("appellant_id") @db.Uuid
  reason             String       @db.Text
  status             AppealStatus @default(PENDING)
  reviewerId         String?      @map("reviewer_id") @db.Uuid
  decisionReasoning  String?      @map("decision_reasoning") @db.Text
  createdAt          DateTime     @default(now()) @map("created_at")
  resolvedAt         DateTime?    @map("resolved_at")

  // Relations
  moderationAction ModerationAction @relation(fields: [moderationActionId], references: [id], onDelete: Cascade)
  appellant        User             @relation(fields: [appellantId], references: [id])
  reviewer         User?            @relation("AppealReviewer", fields: [reviewerId], references: [id])

  @@unique([moderationActionId, appellantId])
  @@index([moderationActionId])
  @@index([status])
  @@map("appeals")
}

enum AppealStatus {
  PENDING
  UNDER_REVIEW
  UPHELD
  DENIED

  @@map("appeal_status")
}

// ============================================================================
// ONBOARDING ENTITIES (Feature 003)
// ============================================================================

/// Authentication method used for user signup
enum AuthMethod {
  EMAIL_PASSWORD
  GOOGLE_OAUTH
  APPLE_OAUTH

  @@map("auth_method")
}

/// Onboarding step progression
enum OnboardingStep {
  VERIFICATION
  TOPICS
  ORIENTATION
  COMPLETE

  @@map("onboarding_step")
}

/// Topic activity level for selection guidance
enum ActivityLevel {
  HIGH
  MEDIUM
  LOW

  @@map("activity_level")
}

/// Account status for user management
enum AccountStatus {
  ACTIVE
  SUSPENDED
  DELETED

  @@map("account_status")
}

/// Email verification token for signup flow
model VerificationToken {
  id        String    @id @default(uuid()) @db.Uuid
  userId    String    @map("user_id") @db.Uuid
  token     String    @unique @db.VarChar(6)
  createdAt DateTime  @default(now()) @map("created_at")
  expiresAt DateTime  @map("expires_at")
  used      Boolean   @default(false)
  usedAt    DateTime? @map("used_at")

  @@index([userId])
  @@index([expiresAt])
  @@map("verification_tokens")
}

/// Tracks user progress through onboarding steps
model OnboardingProgress {
  id                String         @id @default(uuid()) @db.Uuid
  userId            String         @unique @map("user_id") @db.Uuid
  emailVerified     Boolean        @default(false) @map("email_verified")
  topicsSelected    Boolean        @default(false) @map("topics_selected")
  orientationViewed Boolean        @default(false) @map("orientation_viewed")
  firstPostMade     Boolean        @default(false) @map("first_post_made")
  currentStep       OnboardingStep @map("current_step")
  lastUpdatedAt     DateTime       @updatedAt @map("last_updated_at")
  completedAt       DateTime?      @map("completed_at")

  @@index([currentStep])
  @@index([completedAt])
  @@map("onboarding_progress")
}

/// User's selected topic interests for personalization
model TopicInterest {
  id         String   @id @default(uuid()) @db.Uuid
  userId     String   @map("user_id") @db.Uuid
  topicId    String   @map("topic_id") @db.Uuid
  priority   Int      @db.SmallInt
  selectedAt DateTime @default(now()) @map("selected_at")

  user  User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  topic DiscussionTopic @relation(fields: [topicId], references: [id], onDelete: Cascade)

  @@unique([userId, topicId])
  @@index([userId, priority])
  @@map("topic_interests")
}

/// Pre-authentication visitor session tracking for demo
model VisitorSession {
  id                      String     @id @default(uuid()) @db.Uuid
  sessionId               String     @unique @map("session_id")
  viewedDemoDiscussionIds String[]   @default([]) @map("viewed_demo_discussion_ids") @db.Uuid
  interactionTimestamps   DateTime[] @default([]) @map("interaction_timestamps")
  referralSource          String?    @map("referral_source")
  convertedToUserId       String?    @unique @map("converted_to_user_id") @db.Uuid
  createdAt               DateTime   @default(now()) @map("created_at")
  lastActivityAt          DateTime   @updatedAt @map("last_activity_at")

  @@index([convertedToUserId])
  @@index([lastActivityAt])
  @@map("visitor_sessions")
}
