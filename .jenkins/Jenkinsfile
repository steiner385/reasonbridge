#!/usr/bin/env groovy
/**
 * CI Pipeline for uniteDiscord
 *
 * Pipeline structure stays here (required by Jenkins Declarative syntax).
 * Stage implementations are in the shared library for reusability.
 *
 * Shared library: https://github.com/steiner385/unitediscord-jenkins-lib
 *
 * Webhook Setup:
 *   URL: https://jenkins.kindash.com/generic-webhook-trigger/invoke?token=uniteDiscord-ci
 *   Content type: application/json
 *   Events: Push events, Pull request events
 */

@Library('unitediscord-lib@main') _

// Get pipeline configuration from shared library
def cfg = standardPipeline.config(
    githubOwner: 'steiner385',
    githubRepo: 'uniteDiscord',
    webhookToken: 'uniteDiscord-ci',
    statusContext: 'Jenkins CI'
)

pipeline {
    agent any

    options {
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '30'))
        timeout(time: cfg.timeoutMinutes, unit: 'MINUTES')
        disableConcurrentBuilds(abortPrevious: true)
    }

    triggers {
        GenericTrigger(
            genericVariables: [
                [key: 'ref', value: '$.ref'],
                [key: 'after', value: '$.after'],
                [key: 'repository_name', value: '$.repository.name'],
                [key: 'pusher_name', value: '$.pusher.name', defaultValue: 'unknown']
            ],
            causeString: 'Triggered by push to $ref by $pusher_name',
            token: cfg.webhookToken,
            printContributedVariables: true,
            printPostContent: false,
            silentResponse: false,
            regexpFilterText: '$repository_name',
            regexpFilterExpression: '^uniteDiscord$'
        )
    }

    environment {
        GITHUB_OWNER = "${cfg.githubOwner}"
        GITHUB_REPO = "${cfg.githubRepo}"
        CI = 'true'
        NODE_ENV = 'test'
        PATH = "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
        BRANCH_NAME = "${params.ref ? params.ref.replaceAll('refs/heads/', '') : 'main'}"
    }

    stages {
        stage('Initialize') {
            steps {
                script {
                    standardPipeline.initializeCheckout(cfg)
                }
                script {
                    standardPipeline.reportPending(cfg.statusContext)
                }
                sh 'rm -rf frontend/frontend || true'
            }
        }

        stage('Install Dependencies') {
            steps {
                installDependencies()
            }
        }

        stage('Build Packages') {
            when {
                expression { return cfg.buildPackages }
            }
            steps {
                script {
                    standardPipeline.buildPackages()
                }
            }
        }

        stage('Lint') {
            when {
                expression { return cfg.runLint }
            }
            steps {
                script {
                    standardPipeline.runLint()
                }
            }
        }

        stage('Unit Tests') {
            when {
                expression { return cfg.runUnitTests }
            }
            steps {
                script {
                    standardPipeline.runUnitTests()
                }
            }
            post {
                always {
                    junit allowEmptyResults: true, testResults: 'coverage/junit.xml'
                }
            }
        }

        stage('Build') {
            when {
                expression { return cfg.runBuild }
            }
            steps {
                script {
                    standardPipeline.runBuild()
                }
            }
        }
    }

    post {
        success {
            echo 'Build succeeded!'
            script {
                standardPipeline.reportSuccess(cfg.statusContext)
            }
        }
        failure {
            echo 'Build failed!'
            script {
                standardPipeline.reportFailure(cfg.statusContext)
            }
        }
    }
}
